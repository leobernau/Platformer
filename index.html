<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cute Platformer</title>
<style>
  html,body { height:100%; margin:0; background: linear-gradient(180deg,#FFF9FB,#F0F9FF); font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
  #gameCanvas { display:block; width:100vw; height:100vh; background: transparent; }
  #overlay { position:absolute; inset:0; pointer-events:none; }
  .menu { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background: rgba(6,6,12,0.25); backdrop-filter: blur(6px); color:#fff; flex-direction:column; gap:12px; pointer-events:auto; padding:18px; }
  .btn { pointer-events:auto; border:0; padding:10px 18px; border-radius:10px; cursor:pointer; font-weight:600; }
  .btn.primary { background: linear-gradient(180deg,#FFD6E0,#FF9CCC); }
  .btn.alt { background: linear-gradient(180deg,#D7F0FF,#A9E0FF); }
  .btn.danger { background: linear-gradient(180deg,#FFBDBD,#FF8A8A); }
  #hud { position:absolute; left:0; right:0; top:8px; display:flex; justify-content:center; pointer-events:none; }
  #hud .level { font-size:36px; color:#222; font-weight:700; background: rgba(255,255,255,0.9); padding:8px 16px; border-radius:14px; }
  #sideHud { position:absolute; left:12px; top:12px; pointer-events:none; display:flex; flex-direction:column; gap:8px; }
  .chip { background: rgba(255,255,255,0.95); padding:6px 10px; border-radius:10px; color:#222; font-weight:600; pointer-events:none; }
  #legend { position:absolute; right:12px; top:12px; pointer-events:none; background: rgba(255,255,255,0.95); padding:8px 10px; border-radius:10px; font-size:13px; color:#222; }
  #controls { position:absolute; bottom:12px; left:12px; background: rgba(255,255,255,0.95); padding:8px 10px; border-radius:10px; color:#222; pointer-events:none; font-size:13px; }
  #levelSelectGrid { display:grid; grid-template-columns: repeat(10, 36px); gap:6px; margin-top:10px; max-height:240px; overflow:auto; padding:6px; }
  .levelButton { width:36px; height:36px; border-radius:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:13px; color:#222; background:rgba(255,255,255,0.9); pointer-events:auto; }
  .locked { filter:grayscale(1) opacity(0.6); cursor:not-allowed; pointer-events:none; }
  #shopGrid { display:grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:10px; margin-top:10px; width:720px; max-width:95%; }
  .skinCard { background: rgba(255,255,255,0.95); padding:10px; border-radius:12px; text-align:center; color:#222; pointer-events:auto; }
  .skinPreview { width:64px; height:84px; margin:0 auto 8px; border-radius:8px; display:flex; align-items:center; justify-content:center; font-weight:700; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
  @media (max-width:720px) { #hud .level { font-size:26px; padding:6px 12px; } #shopGrid { grid-template-columns:repeat(2,1fr); } }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="overlay">
  <div id="hud"><div class="level" id="levelDisplay">Level 1 / 100</div></div>

  <div id="sideHud">
    <div class="chip" id="coinChip">Coins: 0</div>
    <div class="chip" id="progressChip">Unlocked: 1</div>
  </div>

  <div id="legend">
    Legend:
    <div style="display:flex; gap:8px; margin-top:6px; flex-wrap:wrap;">
      <div style="width:12px;height:12px;background:#CDE8FF;border-radius:3px;"></div><div style="font-size:12px">Normal</div>
      <div style="width:12px;height:12px;background:#D8C6FF;border-radius:3px;margin-left:6px"></div><div style="font-size:12px">Moving</div>
      <div style="width:12px;height:12px;background:#C8FFD0;border-radius:3px;margin-left:6px"></div><div style="font-size:12px">Boost</div>
      <div style="width:12px;height:12px;background:#FFCCCC;border-radius:3px;margin-left:6px"></div><div style="font-size:12px">Spikes</div>
      <div style="width:12px;height:12px;background:#FFE3BF;border-radius:3px;margin-left:6px"></div><div style="font-size:12px">Breaking</div>
    </div>
  </div>

  <div id="controls">←/A →/D = move • Space = jump • P = pause • R = restart</div>

  <div id="menu" class="menu">
    <h1 id="menuTitle">✨ Cute Platformer ✨</h1>
    <p id="menuDesc">100 playable levels — spikes are placed so there's always a safe path. Progress saves locally. Visit the Shop to buy skins with coins you collect.</p>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button id="startBtn" class="btn primary">Start (Space)</button>
      <button id="openSelectBtn" class="btn alt">Level Select</button>
      <button id="openShopBtn" class="btn alt">Shop</button>
      <button id="resetProgressBtn" class="btn danger">Reset Progress</button>
    </div>

    <div id="levelSelect" style="display:none; margin-top:10px; width:760px; max-width:95%;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700;">Level Select</div>
        <div><button id="closeSelectBtn" class="btn alt">Close</button></div>
      </div>
      <div id="levelSelectGrid"></div>
    </div>

    <div id="shopPanel" style="display:none; margin-top:10px; width:760px; max-width:95%; flex-direction:column; align-items:center;">
      <div style="display:flex; width:100%; justify-content:space-between; align-items:center;">
        <div style="font-weight:700;">Shop</div>
        <div><button id="closeShopBtn" class="btn alt">Close</button></div>
      </div>
      <div style="margin-top:8px; font-size:13px; color:#222;">Spend coins to unlock skins. Equip from Owned tab.</div>
      <div id="shopGrid"></div>
    </div>

    <p style="font-size:13px; opacity:0.9; margin-top:6px">If a level feels too hard, you can select any unlocked level from the Level Select. Progress is saved automatically, and skins persist across sessions.</p>
  </div>
</div>

<script>
/* Cute Platformer — Spike spacing + Shop
   - Guarantees a reachable path by removing spike overlays when necessary.
   - Adds Skin Shop: buy with coins, equip, persist in localStorage.
   - All prior gameplay features retained.
*/

/* ---------------------------
   Configuration
   --------------------------- */
const LEVEL_COUNT = 100;
const BASE_LEVEL_WIDTH = 1100;
const EXTRA_WIDTH_PER_LEVEL = 40;

const PLAYER_CONFIG = {
  w: 40, h: 52,
  speedAccel: 0.36,
  maxSpeed: 6.3,         // approximate horizontal speed per frame
  jumpStrength: 11.6,
  gravity: 0.5,
  coyoteTime: 140,
  jumpBuffer: 140
};

// Base probabilities for platform types (moving/boost/breaking)
const PROB_BASE = { moving:0.08, boost:0.06, breaking:0.06 };
// Spike overlay base chance (per eligible platform)
const SPIKE_OVERLAY_BASE = 0.08;

const MOVING_SPEED_RANGE = [0.6,2.2];
const MOVING_RANGE_MIN = 60;
const BREAK_DELAY_MS = 420;
const COIN_BASE = 6;

/* ---------------------------
   Shop & Persistence
   --------------------------- */
const STORAGE_KEY = 'cute_platformer_save_shop_v1';

/* Shop skins — each skin: id, name, color, price.
   The "default" is free and owned by default.
*/
const SKINS = [
  { id:'default', name:'Sunbeam', color:'#FFD28A', price:0 },
  { id:'mint', name:'Minty', color:'#C8FFD0', price:25 },
  { id:'lavender', name:'Lavender', color:'#D8C6FF', price:45 },
  { id:'peach', name:'Peach', color:'#FFDAC1', price:75 },
  { id:'starlight', name:'Starlight', color:'#FFF59A', price:120 },
];

/* load/save structure:
   {
     highestUnlocked: 1..LEVEL_COUNT,
     totalCoins: number,
     ownedSkins: [ids...],
     equippedSkin: 'id'
   }
*/
function loadSave(){
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return { highestUnlocked:1, totalCoins:0, ownedSkins:['default'], equippedSkin:'default' };
    const p = JSON.parse(raw);
    return {
      highestUnlocked: Math.max(1, Math.min(LEVEL_COUNT, p.highestUnlocked || 1)),
      totalCoins: p.totalCoins || 0,
      ownedSkins: Array.isArray(p.ownedSkins) ? p.ownedSkins : ['default'],
      equippedSkin: p.equippedSkin || 'default'
    };
  } catch {
    return { highestUnlocked:1, totalCoins:0, ownedSkins:['default'], equippedSkin:'default' };
  }
}
function saveProgress(state){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
function resetProgress(){ localStorage.removeItem(STORAGE_KEY); save = { highestUnlocked:1, totalCoins:0, ownedSkins:['default'], equippedSkin:'default' }; applySaveUI(); buildShopGrid(); }

/* ---------------------------
   Canvas & UI nodes
   --------------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
window.addEventListener('resize', ()=> { W = canvas.width = innerWidth; H = canvas.height = innerHeight; camera.x = Math.max(0, player.x - W*0.35); });

const levelDisplay = document.getElementById('levelDisplay');
const coinChip = document.getElementById('coinChip');
const progressChip = document.getElementById('progressChip');
const menuEl = document.getElementById('menu');
const startBtn = document.getElementById('startBtn');
const openSelectBtn = document.getElementById('openSelectBtn');
const openShopBtn = document.getElementById('openShopBtn');
const resetProgressBtn = document.getElementById('resetProgressBtn');
const levelSelect = document.getElementById('levelSelect');
const closeSelectBtn = document.getElementById('closeSelectBtn');
const levelSelectGrid = document.getElementById('levelSelectGrid');
const shopPanel = document.getElementById('shopPanel');
const closeShopBtn = document.getElementById('closeShopBtn');
const shopGrid = document.getElementById('shopGrid');
const menuTitle = document.getElementById('menuTitle');
const menuDesc = document.getElementById('menuDesc');

/* ---------------------------
   State
   --------------------------- */
let save = loadSave();
let currentLevelIndex = Math.max(0, Math.min(LEVEL_COUNT-1, save.highestUnlocked-1));
let levels = [];
let level = null;
let running = false;
let paused = false;
let lastFrame = performance.now();
let coinsThisLevel = 0;

/* ---------------------------
   Player & camera
   --------------------------- */
const player = {
  x: 120, y: H - 220, w: 40, h: 52,
  vx: 0, vy: 0,
  speedAccel: PLAYER_CONFIG.speedAccel,
  maxSpeed: PLAYER_CONFIG.maxSpeed,
  jumpStrength: PLAYER_CONFIG.jumpStrength,
  gravity: PLAYER_CONFIG.gravity,
  onGround:false, facing:1, coyoteTimer:0, jumpBufferTimer:0,
  coyoteTime: PLAYER_CONFIG.coyoteTime, jumpBuffer: PLAYER_CONFIG.jumpBuffer
};
const camera = { x:0, y:0 };

/* ---------------------------
   Input
   --------------------------- */
const keys = {};
window.addEventListener('keydown', (e)=> {
  keys[e.key.toLowerCase()] = true;
  if (!running && e.key === ' ') startGame();
  if (e.key === 'p') paused = !paused;
  if (e.key === 'r' && running) restartLevel();
});
window.addEventListener('keyup', (e)=> keys[e.key.toLowerCase()] = false);

/* ---------------------------
   Helpers
   --------------------------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function randRange(a,b){ return a + Math.random()*(b-a); }
function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

/* Conservative horizontal reach used to cap gaps.
   Uses a conservative multiplier so jumps remain achievable.
*/
function computeConservativeMaxGap(){
  const frames = 2 * PLAYER_CONFIG.jumpStrength / PLAYER_CONFIG.gravity;
  const reach = PLAYER_CONFIG.maxSpeed * frames;
  return Math.round(clamp(reach * 0.78, 140, 700));
}

/* ---------------------------
   Level generation with spike overlay + reachability check
   --------------------------- */
function generateLevels(){
  levels.length = 0;
  const conservativeMaxGap = computeConservativeMaxGap();
  for (let i=0;i<LEVEL_COUNT;i++){
    const difficulty = i / (LEVEL_COUNT - 1);
    const width = Math.round(BASE_LEVEL_WIDTH + i * EXTRA_WIDTH_PER_LEVEL + Math.random()*420);
    const baseY = H - 80;
    const platforms = [];
    // start
    platforms.push({ x:0, y: baseY - 18, w: Math.min(600, 260 + Math.round(200 - difficulty*120)), h:20, type:'normal', hasSpike:false });
    const maxVerticalStep = Math.round(220 + difficulty * 120);
    let cursor = 300;
    const segments = 7 + Math.round(difficulty * 16);

    for (let seg=0; seg<segments && cursor < width - 260; seg++){
      const pCount = 1 + Math.floor(Math.random()*2);
      for (let p=0;p<pCount && cursor < width - 200; p++){
        let type = 'normal';
        const r = Math.random();
        const movingChance = PROB_BASE.moving + difficulty*0.08;
        const boostChance = PROB_BASE.boost + difficulty*0.04;
        const breakingChance = PROB_BASE.breaking + difficulty*0.04;

        if (r < movingChance) type = 'moving';
        else if (r < movingChance + boostChance) type = 'boost';
        else if (r < movingChance + boostChance + breakingChance) type = 'breaking';

        // placement with retries
        let attempts = 0;
        let placed = false;
        let px=0, py=0, pw=0;
        const prev = platforms[platforms.length-1];
        while (!placed && attempts < 160) {
          attempts++;
          let gap = 80 + Math.round(Math.random() * Math.max(80, conservativeMaxGap - 80));
          if (Math.random() < 0.18) gap = Math.round(gap * (0.6 + Math.random()*0.6));
          pw = 80 + Math.round(Math.random() * (120 + difficulty*80));
          px = cursor + gap;
          const yVariation = Math.round(Math.random() * (maxVerticalStep));
          py = Math.max(120, Math.min(baseY - 20, prev.y - Math.round(60 - Math.random()*120) + yVariation - (Math.random()*60)));
          const dx = px - (prev.x + prev.w);
          if (dx <= conservativeMaxGap) { placed = true; break; }
          if ((prev && prev.type === 'boost') && dx <= conservativeMaxGap * 1.22) { placed = true; break; }
          if ((type === 'boost') && dx <= conservativeMaxGap * 1.22) { placed = true; break; }
          gap = Math.max(80, Math.round(gap * 0.7));
          cursor -= Math.round((Math.random()*16));
          if (attempts > 100) { px = prev.x + prev.w + Math.round(conservativeMaxGap * (0.9 + Math.random()*0.05)); placed = true; break; }
        }
        const plat = { x:px, y:py, w:pw, h:18, type, hasSpike:false };
        if (type === 'moving') {
          if (Math.random() < 0.76) {
            const range = Math.round(MOVING_RANGE_MIN + Math.random()*Math.max(80, conservativeMaxGap*0.28 + difficulty*120));
            plat.moving = { axis:'x', range, speed: randRange(MOVING_SPEED_RANGE[0], MOVING_SPEED_RANGE[1]) * (1 + difficulty*0.18) };
          } else {
            const range = Math.round(MOVING_RANGE_MIN/2 + Math.random()*100 + difficulty*80);
            plat.moving = { axis:'y', range, speed: randRange(MOVING_SPEED_RANGE[0], MOVING_SPEED_RANGE[1]) * (1 + difficulty*0.16) };
          }
          plat.startX = plat.x; plat.startY = plat.y; plat._dir = 1; plat._offset = 0;
        } else if (type === 'breaking') {
          plat.breaking = { stepping:false, timer:0 }; plat._gone = false;
        } else if (type === 'boost') {
          plat.boost = { multiplier: 1.45 + Math.random()*0.35 };
        }
        platforms.push(plat);
        cursor = px + pw + 20;
      }
      cursor += 200 + Math.round(Math.random() * (120 + difficulty * 420));
    }

    // final platform
    let lastPlat = platforms[platforms.length-1];
    let finalX = Math.max(cursor + 100, width - 360);
    let finalY = Math.max(120, Math.min(baseY - 20, lastPlat.y - 10 - Math.round(difficulty * 120)));
    const dxFinal = finalX - (lastPlat.x + lastPlat.w);
    if (dxFinal > conservativeMaxGap) {
      const boostX = lastPlat.x + lastPlat.w + Math.round(conservativeMaxGap * 0.6);
      platforms.push({ x:boostX, y: lastPlat.y - Math.round(30 + Math.random()*40), w:140, h:18, type:'boost', boost:{multiplier:1.55}, hasSpike:false });
      finalX = boostX + 220;
      finalY = Math.max(120, Math.min(baseY - 20, platforms[platforms.length-1].y - 40));
    }
    const finalPlat = { x: finalX, y: finalY, w:240, h:22, type:'normal', hasSpike:false };
    platforms.push(finalPlat);

    // coins
    const coins = [];
    const coinCount = COIN_BASE + Math.round(difficulty * 10);
    for (let c=0;c<coinCount;c++){
      const p = platforms[Math.floor(Math.random()*platforms.length)];
      const cx = p.x + 16 + Math.random() * Math.max(20, p.w - 32);
      const cy = p.y - 26 - Math.random() * 40;
      coins.push({ x:cx, y:cy, r:8, collected:false });
    }

    const star = { x: finalPlat.x + finalPlat.w/2, y: finalPlat.y - 44, r: 18 };

    // Spike overlay assignment (initial pass)
    const spikeChanceScaled = SPIKE_OVERLAY_BASE + difficulty * 0.05;
    for (let pi = 1; pi < platforms.length - 1; pi++) {
      const p = platforms[pi];
      p.hasSpike = false;
      // never place on boost/breaking or start/final or tiny platforms
      if (p.type === 'boost' || p.type === 'breaking') continue;
      if (p.w < 80) continue;
      if (Math.random() < spikeChanceScaled) {
        // ensure not extremely high relative to previous platform (avoid unfair on high ledge)
        const prev = platforms[Math.max(0, pi - 1)];
        if (Math.abs(p.y - prev.y) > 180) continue;
        p.hasSpike = true;
      }
    }

    // Now ensure spikes do not block progression:
    // Build graph of reachability ignoring spiked platforms.
    const reachable = ensureReachablePath(platforms, conservativeMaxGap);
    // if not reachable, ensureReachablePath will remove spikes until path exists.
    levels.push({ platforms, coins, star, width: Math.max(width, finalPlat.x + finalPlat.w + 100), baseY });
  }
}

/* Graph reachability check (platform-level)
   - nodes = platform indices
   - edge i->j exists if player could jump from platform i to j using conservative rules
   - treat platforms with hasSpike==true as blocked; try removing spikes until path exists
*/
function ensureReachablePath(platforms, conservativeMaxGap) {
  function canJump(from, to) {
    // from, to are platform objects
    if (!from || !to) return false;
    // horizontal gap from right edge of from to left edge of to
    const dx = to.x - (from.x + from.w);
    if (dx < -10) return false; // overlapping backwards
    if (dx > conservativeMaxGap) return false;
    // height difference
    const dy = to.y - from.y;
    // allow some vertical difference (player can jump up some)
    if (dy < -260) return false; // too high up above
    if (dy > 380) return false;  // too far down (shouldn't matter)
    return true;
  }

  // build adjacency for the level
  const n = platforms.length;
  function buildAdj(blockSpikes) {
    const adj = Array.from({length:n}, ()=>[]);
    for (let i=0;i<n;i++){
      for (let j=i+1;j<n;j++){
        if (!canJump(platforms[i], platforms[j])) continue;
        // If target platform is marked as spike AND we're treating spikes as blocked, then don't add
        if (blockSpikes && platforms[j].hasSpike) continue;
        adj[i].push(j);
      }
    }
    return adj;
  }

  function bfs(adj) {
    const q = [0];
    const visited = new Array(n).fill(false); visited[0]=true;
    while (q.length){
      const u = q.shift();
      if (u === n-1) return true;
      for (const v of adj[u]) {
        if (!visited[v]) { visited[v]=true; q.push(v); }
      }
    }
    return false;
  }

  // First test: graph with spike platforms treated as blocked
  let adj = buildAdj(true);
  if (bfs(adj)) return true;

  // If blocked, progressively remove spikes until BFS succeeds.
  // Strategy: remove spikes starting from earlier platforms (closer to start) to open paths.
  // We'll create a list of candidate spike platforms (excluding start/final)
  const spikeIndices = [];
  for (let i=1;i<n-1;i++){
    if (platforms[i].hasSpike) spikeIndices.push(i);
  }
  // sort by distance from start (prefer removing spikes earlier so player can progress)
  spikeIndices.sort((a,b)=> a - b);

  // Iteratively remove spikes until path becomes reachable or we ran out
  for (let idx of spikeIndices) {
    platforms[idx].hasSpike = false;
    adj = buildAdj(true);
    if (bfs(adj)) return true;
  }

  // As a last fallback, if still blocked, remove all spikes and return true (should not happen often)
  for (let i=1;i<n-1;i++) platforms[i].hasSpike = false;
  return true;
}

/* Generate levels now (calls ensureReachablePath so we get safe spike placement) */
generateLevels();

/* ---------------------------
   Load level (deep copy)
   --------------------------- */
function loadLevel(index){
  currentLevelIndex = clamp(index, 0, LEVEL_COUNT-1);
  level = JSON.parse(JSON.stringify(levels[currentLevelIndex]));
  // re-init runtime fields for moving/breaking platforms
  for (const p of level.platforms) {
    if (p.moving) { p.x = p.startX; p.y = p.startY; p._dir = 1; p._offset = 0; }
    if (p.breaking) { p.breaking.stepping = false; p.breaking.timer = 0; p._gone = false; }
  }
  level.coins.forEach(c=> c.collected = false);
  player.x = 120; player.y = H - 220; player.vx = 0; player.vy = 0; player.onGround=false;
  player.coyoteTimer = 0; player.jumpBufferTimer = 0;
  coinsThisLevel = 0; camera.x = 0;
  updateHUD();
}

/* ---------------------------
   HUD, UI & Shop rendering logic
   --------------------------- */
function applySaveUI(){
  progressChip.textContent = 'Unlocked: ' + (save.highestUnlocked || 1);
  coinChip.textContent = 'Coins: ' + ((save.totalCoins || 0) + coinsThisLevel);
}
function updateHUD(){
  levelDisplay.textContent = `Level ${currentLevelIndex + 1} / ${LEVEL_COUNT}`;
  coinChip.textContent = 'Coins: ' + ((save.totalCoins || 0) + coinsThisLevel);
  progressChip.textContent = 'Unlocked: ' + (save.highestUnlocked || 1);
}

/* Build level select grid */
function buildLevelSelectGrid(){
  levelSelectGrid.innerHTML = '';
  for (let i=0;i<LEVEL_COUNT;i++){
    const btn = document.createElement('div');
    btn.className = 'levelButton';
    btn.textContent = i+1;
    if (i+1 > (save.highestUnlocked || 1)) btn.classList.add('locked');
    else btn.addEventListener('click', ()=> { currentLevelIndex = i; startGame(); });
    levelSelectGrid.appendChild(btn);
  }
}

/* Build shop UI grid */
function buildShopGrid(){
  shopGrid.innerHTML = '';
  for (const skin of SKINS) {
    const card = document.createElement('div');
    card.className = 'skinCard';
    const preview = document.createElement('div');
    preview.className = 'skinPreview';
    preview.style.background = skin.color;
    preview.style.color = '#222';
    preview.textContent = skin.name.split('')[0]; // single letter as cute preview
    const title = document.createElement('div');
    title.textContent = skin.name;
    title.style.fontWeight = '700';
    title.style.marginTop = '6px';
    const price = document.createElement('div');
    price.textContent = skin.price === 0 ? 'Free' : `${skin.price} coins`;
    price.style.marginTop = '6px';
    const btn = document.createElement('button');
    btn.className = 'btn alt';
    btn.style.marginTop = '8px';
    // Owned?
    const owned = (save.ownedSkins || []).includes(skin.id);
    if (owned) {
      btn.textContent = (save.equippedSkin === skin.id) ? 'Equipped' : 'Equip';
      btn.addEventListener('click', ()=> {
        save.equippedSkin = skin.id;
        saveProgress(save);
        applySaveUI();
        buildShopGrid();
      });
    } else {
      btn.textContent = 'Buy';
      btn.addEventListener('click', ()=> {
        const totalCoins = save.totalCoins || 0;
        if (skin.price <= totalCoins) {
          save.totalCoins = totalCoins - skin.price;
          (save.ownedSkins || (save.ownedSkins=[])).push(skin.id);
          save.equippedSkin = skin.id;
          saveProgress(save);
          applySaveUI();
          buildShopGrid();
        } else {
          alert('Not enough coins to buy this skin.');
        }
      });
    }
    card.appendChild(preview);
    card.appendChild(title);
    card.appendChild(price);
    card.appendChild(btn);
    shopGrid.appendChild(card);
  }
}

/* ---------------------------
   Collision helpers (same as before)
   --------------------------- */
function rectIntersects(a,b){ return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); }
function resolveCollision(px,py,pw,ph,plat){
  const p = {x:px,y:py,w:pw,h:ph}, q = {x:plat.x,y:plat.y,w:plat.w,h:plat.h};
  if (!rectIntersects(p,q)) return null;
  const ox1 = (p.x + p.w) - q.x, ox2 = (q.x + q.w) - p.x, oy1 = (p.y + p.h) - q.y, oy2 = (q.y + q.h) - p.y;
  const m = Math.min(ox1,ox2,oy1,oy2);
  if (m === oy1) return { side:'top', y: q.y - p.h };
  if (m === oy2) return { side:'bottom', y: q.y + q.h };
  if (m === ox1) return { side:'left', x: q.x - p.w };
  return { side:'right', x: q.x + q.w };
}

/* ---------------------------
   Particles
   --------------------------- */
const particles = [];
function spawnParticles(x,y,color,count=8){
  for (let i=0;i<count;i++){
    particles.push({
      x,y,
      vx: randRange(-1.6,1.6),
      vy: randRange(-3.2,-0.6),
      life: 420 + Math.random()*220,
      color, size: 2 + Math.random()*3
    });
  }
}
function updateParticles(dt){
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= dt;
    if (p.life <= 0) { particles.splice(i,1); continue; }
    p.vy += 0.06 * (dt/16.67);
    p.x += p.vx * (dt/16.67);
    p.y += p.vy * (dt/16.67);
  }
}

/* ---------------------------
   Game update & drawing
   --------------------------- */
function startGame(){
  if (currentLevelIndex + 1 > save.highestUnlocked) currentLevelIndex = save.highestUnlocked - 1;
  loadLevel(currentLevelIndex);
  running = true; paused = false;
  menuEl.style.display = 'none';
  lastFrame = performance.now();
  requestAnimationFrame(loop);
}
function restartLevel(){ loadLevel(currentLevelIndex); running = true; paused = false; menuEl.style.display = 'none'; }
function goToMenu(title,msg){ running=false; paused=false; menuEl.style.display='flex'; menuTitle.textContent = title; menuDesc.textContent = msg; buildLevelSelectGrid(); buildShopGrid(); }

function loop(now){
  if (!running) return;
  const dt = Math.min(40, now - lastFrame);
  lastFrame = now;
  if (!paused) update(dt);
  draw();
  if (running) requestAnimationFrame(loop);
}

function update(dt){
  const left = keys['arrowleft'] || keys['a'];
  const right = keys['arrowright'] || keys['d'];
  const jumpKey = keys[' '] || keys['spacebar'];

  const acc = player.speedAccel * dt;
  if (left) player.vx -= acc, player.facing = -1;
  if (right) player.vx += acc, player.facing = 1;
  if (!left && !right) player.vx *= 0.86;
  player.vx = clamp(player.vx, -player.maxSpeed, player.maxSpeed);

  player.vy += player.gravity * (dt / 16.67);

  if (jumpKey) player.jumpBufferTimer = player.jumpBuffer; else player.jumpBufferTimer = Math.max(0, player.jumpBufferTimer - dt);
  player.coyoteTimer = Math.max(0, player.coyoteTimer - dt);

  // integrate
  player.x += player.vx;
  player.y += player.vy;

  // clamp X
  if (player.x < -40) player.x = -40;
  if (player.x > level.width - player.w + 40) player.x = level.width - player.w + 40;

  // update moving platforms & breaking timers
  for (const p of level.platforms){
    if (p._gone) continue;
    if (p.type === 'moving' && p.moving){
      if (p.moving.axis === 'x'){ p._offset = (p._offset || 0) + p.moving.speed * p._dir; p.x = p.startX + p._offset; if (Math.abs(p._offset) >= p.moving.range) p._dir *= -1; }
      else { p._offset = (p._offset || 0) + p.moving.speed * p._dir; p.y = p.startY + p._offset; if (Math.abs(p._offset) >= p.moving.range) p._dir *= -1; }
    }
    if (p.type === 'breaking' && p.breaking && p.breaking.timer > 0){ p.breaking.timer -= dt; if (p.breaking.timer <= 0) p._gone = true; }
  }

  // collisions
  player.onGround = false;
  let standingOn = null;
  for (const p of level.platforms){
    if (p._gone) continue;
    const res = resolveCollision(player.x, player.y, player.w, player.h, p);
    if (!res) continue;
    if (res.side === 'top'){
      player.y = res.y; player.vy = 0; player.onGround = true; standingOn = p; player.coyoteTimer = player.coyoteTime;
      if (p.type === 'moving' && p.moving && p.moving.axis === 'x') player.x += p.moving.speed * p._dir;
      if (p.type === 'breaking' && p.breaking && !p.breaking.stepping) { p.breaking.stepping = true; p.breaking.timer = BREAK_DELAY_MS; }
      // if there are spikes on this platform, landing means death
      if (p.hasSpike) { goToMenu('Ouch — spike!', 'You landed on spikes. Back to menu.'); return; }
    } else if (res.side === 'bottom') { player.y = res.y; player.vy = Math.max(0, player.vy); }
    else if (res.side === 'left') { player.x = res.x; player.vx = Math.min(0, player.vx); }
    else { player.x = res.x; player.vx = Math.max(0, player.vx); }
  }

  // compute effective jump strength if standing on boost
  const effectiveJumpStrength = (standingOn && standingOn.type === 'boost' && standingOn.boost) ? (PLAYER_CONFIG.jumpStrength * standingOn.boost.multiplier) : PLAYER_CONFIG.jumpStrength;

  if (player.jumpBufferTimer > 0 && (player.onGround || player.coyoteTimer > 0)) {
    player.vy = -effectiveJumpStrength;
    player.onGround = false;
    player.coyoteTimer = 0;
    player.jumpBufferTimer = 0;
    if (standingOn && standingOn.type === 'boost') spawnParticles(player.x + player.w/2, player.y + player.h, '#9DF7A8', 12);
  }

  // coins
  for (const c of level.coins){
    if (c.collected) continue;
    const dx = (player.x + player.w/2) - c.x;
    const dy = (player.y + player.h/2) - c.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d < c.r + Math.max(player.w, player.h)/3) {
      c.collected = true;
      coinsThisLevel++;
      save.totalCoins = (save.totalCoins || 0) + 1;
      saveProgress(save);
      spawnParticles(c.x, c.y, '#FFD66B', 10);
      updateHUD();
    }
  }

  // star / goal
  const star = level.star;
  const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
  const starRect = { x: star.x - star.r, y: star.y - star.r, w: star.r*2, h: star.r*2 };
  if (rectIntersects(playerRect, starRect)) {
    if (save.highestUnlocked < currentLevelIndex + 2) { save.highestUnlocked = Math.min(LEVEL_COUNT, currentLevelIndex + 2); }
    saveProgress(save); applySaveUI();
    if (currentLevelIndex < LEVEL_COUNT - 1) { currentLevelIndex++; loadLevel(currentLevelIndex); }
    else { goToMenu('You cleared all levels! 🎉', 'Amazing — you finished all levels.'); }
    return;
  }

  // side spike detection (touching spike area)
  for (const p of level.platforms){
    if (!p.hasSpike) continue;
    const spikeRect = { x: p.x, y: p.y - 6, w: p.w, h: p.h + 8 };
    if (rectIntersects(playerRect, spikeRect)) { goToMenu('Ouch — spike!', 'You touched spikes. Back to menu.'); return; }
  }

  // falling
  if (player.y > H + 160) { goToMenu('You fell! 😿', 'You fell from the level. Back to the menu.'); return; }

  // camera smoothing
  const targetCamX = Math.max(0, player.x - W * 0.35);
  camera.x += (targetCamX - camera.x) * 0.12;

  updateParticles(dt);
  updateHUD();
}

/* ---------------------------
   Drawing
   --------------------------- */
function drawRoundedRect(x,y,w,h,r=10){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }
function drawStar(cx,cy,r,spikes=6){ ctx.save(); ctx.beginPath(); const outer=r, inner=r*0.5; let rot=Math.PI/2*3; let x=cx,y=cy; const step=Math.PI/spikes; ctx.moveTo(cx,cy-outer); for(let i=0;i<spikes;i++){ x=cx+Math.cos(rot)*outer; y=cy+Math.sin(rot)*outer; ctx.lineTo(x,y); rot+=step; x=cx+Math.cos(rot)*inner; y=cy+Math.sin(rot)*inner; ctx.lineTo(x,y); rot+=step;} ctx.closePath(); ctx.fill(); ctx.restore(); }
function drawCoin(x,y,r){ ctx.beginPath(); ctx.ellipse(x,y,r*1.1,r,0,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1; ctx.stroke(); ctx.strokeStyle='transparent'; }

function draw(){
  ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#FFF4F9'); g.addColorStop(0.6,'#F7FBFF'); g.addColorStop(1,'#E7F7FF'); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  // hills
  const hillColors = ['#FDECF7','#E9E9FF','#DDF6F8'];
  for (let i=0;i<3;i++){ ctx.fillStyle = hillColors[i]; ctx.beginPath(); const amp = 80 + i*30; ctx.moveTo(-200, H*0.85 - i*40); for (let x=-200; x<=W+400; x+=60){ const y = H*0.85 - i*40 - Math.sin((x*0.003)+i)*amp; ctx.lineTo(x,y); } ctx.lineTo(W+400,H+200); ctx.lineTo(-200,H+200); ctx.closePath(); ctx.fill(); }
  ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.fillRect(0,H-120,W,120);

  ctx.save(); ctx.translate(-Math.round(camera.x), 0);

  // platforms
  for (const p of level.platforms){
    if (p._gone) continue;
    let color = '#CDE8FF';
    if (p.type === 'moving') color = '#D8C6FF';
    if (p.type === 'boost') color = '#C8FFD0';
    if (p.type === 'breaking') color = '#FFE3BF';
    ctx.fillStyle = color; drawRoundedRect(p.x, p.y, p.w, p.h, 10);
    ctx.fillStyle = 'rgba(255,255,255,0.12)'; drawRoundedRect(p.x+6, p.y+2, Math.max(0,p.w-12), 6, 6);
    if (p.hasSpike) {
      const spikeCount = Math.max(3, Math.round(p.w/26));
      ctx.fillStyle = '#FF5A5A';
      for (let s=0;s<spikeCount;s++){
        const sx = p.x + 6 + (p.w - 12) * (s / Math.max(1,spikeCount-1));
        const sw = Math.min(18, (p.w-12) / spikeCount);
        ctx.beginPath(); ctx.moveTo(sx - sw/2, p.y + p.h); ctx.lineTo(sx, p.y + p.h - Math.min(22, sw*1.2)); ctx.lineTo(sx + sw/2, p.y + p.h); ctx.closePath(); ctx.fill();
      }
      ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font='12px Arial'; ctx.fillText('!', p.x + p.w - 22, p.y + p.h - 6);
    } else {
      if (p.type === 'moving' && p.moving){ ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.font='12px Arial'; if (p.moving.axis==='x') ctx.fillText('⇄', p.x + p.w - 20, p.y + p.h - 6); else ctx.fillText('⇅', p.x + p.w - 20, p.y + p.h - 6); }
      if (p.type === 'boost'){ ctx.fillStyle='rgba(20,200,120,0.9)'; ctx.beginPath(); ctx.arc(p.x + 16, p.y + p.h/2, 8, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='white'; ctx.font='12px Arial'; ctx.fillText('↑', p.x + 12, p.y + p.h/2 + 4); }
      if (p.type === 'breaking' && p.breaking && p.breaking.stepping){ const frac = Math.max(0, Math.min(1, p.breaking.timer / BREAK_DELAY_MS)); ctx.fillStyle = `rgba(210,80,20,${1-frac})`; drawRoundedRect(p.x, p.y, p.w, p.h, 10); }
    }
  }

  // coins
  for (const c of level.coins){ if (c.collected) continue; ctx.fillStyle = '#FFD66B'; drawCoin(c.x, c.y, c.r); ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.ellipse(c.x - c.r*0.18, c.y - c.r*0.28, c.r*0.26, c.r*0.09, 0, 0, Math.PI*2); ctx.fill(); }

  // star
  ctx.save(); ctx.translate(level.star.x, level.star.y); const spin = (performance.now() / 500) % (Math.PI*2); ctx.rotate(spin); ctx.fillStyle = '#FFF59A'; drawStar(0,0,level.star.r,6); ctx.fillStyle = '#FFD54A'; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill(); ctx.restore();

  // draw player using equipped skin color
  const skin = SKINS.find(s => s.id === (save.equippedSkin || 'default')) || SKINS[0];
  ctx.fillStyle = skin.color || '#FFD28A';
  drawRoundedRect(player.x, player.y, player.w, player.h, 10);
  ctx.fillStyle = '#2B2B2B'; ctx.beginPath(); ctx.ellipse(player.x + player.w*0.32, player.y + player.h*0.36, 3.8, 5.2, 0, 0, Math.PI*2); ctx.ellipse(player.x + player.w*0.68, player.y + player.h*0.36, 3.8, 5.2, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = 'rgba(255,105,135,0.12)'; ctx.beginPath(); ctx.ellipse(player.x + player.w*0.2, player.y + player.h*0.6, 8, 4, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(player.x + player.w*0.8, player.y + player.h*0.6, 8, 4, 0, 0, Math.PI*2); ctx.fill();

  // particles
  for (const p of particles){ ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life/600); ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1; }

  ctx.restore();

  if (paused) { ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H); ctx.fillStyle = '#fff'; ctx.font='44px Poppins, Arial'; ctx.textAlign='center'; ctx.fillText('PAUSED', W/2, H/2 - 8); ctx.font='14px Arial'; ctx.fillText('Press P to resume', W/2, H/2 + 22); }
}

/* ---------------------------
   Level select & shop initialization
   --------------------------- */
function buildShopGrid(){
  shopGrid.innerHTML = '';
  for (const skin of SKINS) {
    const card = document.createElement('div'); card.className = 'skinCard';
    const preview = document.createElement('div'); preview.className = 'skinPreview'; preview.style.background = skin.color; preview.textContent = skin.name[0];
    const title = document.createElement('div'); title.textContent = skin.name; title.style.fontWeight = '700'; title.style.marginTop = '6px';
    const price = document.createElement('div'); price.textContent = skin.price === 0 ? 'Free' : `${skin.price} coins`; price.style.marginTop = '6px';
    const btn = document.createElement('button'); btn.className = 'btn alt'; btn.style.marginTop = '8px';
    const owned = (save.ownedSkins || []).includes(skin.id);
    if (owned) {
      btn.textContent = (save.equippedSkin === skin.id) ? 'Equipped' : 'Equip';
      btn.addEventListener('click', ()=> { save.equippedSkin = skin.id; saveProgress(save); applySaveUI(); buildShopGrid(); });
    } else {
      btn.textContent = 'Buy';
      btn.addEventListener('click', ()=> {
        const total = save.totalCoins || 0;
        if (skin.price <= total) {
          save.totalCoins = total - skin.price;
          (save.ownedSkins || (save.ownedSkins=[])).push(skin.id);
          save.equippedSkin = skin.id;
          saveProgress(save);
          applySaveUI();
          buildShopGrid();
        } else {
          alert('Not enough coins.');
        }
      });
    }
    card.appendChild(preview); card.appendChild(title); card.appendChild(price); card.appendChild(btn);
    shopGrid.appendChild(card);
  }
}

/* ---------------------------
   UI event wiring
   --------------------------- */
startBtn.addEventListener('click', ()=> startGame());
openSelectBtn.addEventListener('click', ()=> { levelSelect.style.display = levelSelect.style.display === 'flex' ? 'none' : 'flex'; buildLevelSelectGrid(); });
closeSelectBtn.addEventListener('click', ()=> levelSelect.style.display = 'none');
openShopBtn.addEventListener('click', ()=> { shopPanel.style.display = shopPanel.style.display === 'flex' ? 'none' : 'flex'; buildShopGrid(); });
closeShopBtn.addEventListener('click', ()=> shopPanel.style.display = 'none');
resetProgressBtn.addEventListener('click', ()=> { if (confirm('Reset saved progress? This unlocks only level 1 and clears coins and skins.')) { resetProgress(); buildLevelSelectGrid(); buildShopGrid(); applySaveUI(); menuTitle.textContent = '✨ Cute Platformer ✨'; menuDesc.textContent = 'Progress reset. Press Start to play.'; } });

function buildLevelSelectGrid(){
  levelSelectGrid.innerHTML = '';
  for (let i=0;i<LEVEL_COUNT;i++){
    const btn = document.createElement('div'); btn.className = 'levelButton'; btn.textContent = i+1;
    if (i+1 > (save.highestUnlocked || 1)) btn.classList.add('locked');
    else btn.addEventListener('click', ()=> { currentLevelIndex = i; startGame(); });
    levelSelectGrid.appendChild(btn);
  }
}

/* ---------------------------
   Init & ready
   --------------------------- */
applySaveUI = function(){ progressChip.textContent = 'Unlocked: ' + (save.highestUnlocked || 1); coinChip.textContent = 'Coins: ' + ((save.totalCoins || 0) + coinsThisLevel); };
applySaveUI();
buildLevelSelectGrid();
buildShopGrid();
menuEl.style.display = 'flex';
menuTitle.textContent = '✨ Cute Platformer ✨';
menuDesc.textContent = '100 playable levels — spikes are placed safely; buy skins from the Shop with coins you collect.';

// helper aliases to preserve previous function names
function restartLevel(){ loadLevel(currentLevelIndex); running = true; paused = false; menuEl.style.display = 'none'; }

// (debug) auto-start
// startGame();

</script>
</body>
</html>
