<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cute Platformer ‚Äî 100 Levels (Reachable + Spikes + Boosts)</title>
<style>
  html,body { height:100%; margin:0; background: linear-gradient(180deg,#FFF9FB,#F0F9FF); font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
  #gameCanvas { display:block; width:100vw; height:100vh; background: transparent; }
  #overlay { position:absolute; inset:0; pointer-events:none; }
  .menu {
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    background: rgba(6,6,12,0.25); backdrop-filter: blur(6px);
    color:#fff; flex-direction:column; gap:12px; pointer-events:auto; padding:18px;
  }
  .btn { pointer-events:auto; border:0; padding:10px 18px; border-radius:10px; cursor:pointer; font-weight:600; }
  .btn.primary { background: linear-gradient(180deg,#FFD6E0,#FF9CCC); }
  .btn.alt { background: linear-gradient(180deg,#D7F0FF,#A9E0FF); }
  #hud { position:absolute; left:0; right:0; top:8px; display:flex; justify-content:center; pointer-events:none; }
  #hud .level { font-size:36px; color:#222; font-weight:700; background: rgba(255,255,255,0.9); padding:8px 16px; border-radius:14px; }
  #sideHud { position:absolute; left:12px; top:12px; pointer-events:none; display:flex; flex-direction:column; gap:8px; }
  .chip { background: rgba(255,255,255,0.95); padding:6px 10px; border-radius:10px; color:#222; font-weight:600; pointer-events:none; }
  #legend { position:absolute; right:12px; top:12px; pointer-events:none; background: rgba(255,255,255,0.95); padding:8px 10px; border-radius:10px; font-size:13px; color:#222; }
  #controls { position:absolute; bottom:12px; left:12px; background: rgba(255,255,255,0.95); padding:8px 10px; border-radius:10px; color:#222; pointer-events:none; font-size:13px; }
  #levelSelectGrid { display:grid; grid-template-columns: repeat(10, 36px); gap:6px; margin-top:10px; max-height:240px; overflow:auto; padding:6px; }
  .levelButton { width:36px; height:36px; border-radius:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:13px; color:#222; background:rgba(255,255,255,0.9); pointer-events:auto; }
  .locked { filter:grayscale(1) opacity(0.6); cursor:not-allowed; pointer-events:none; }
  /* small responsive tweaks */
  @media (max-width:720px) {
    #hud .level { font-size:26px; padding:6px 12px; }
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="overlay">
  <div id="hud"><div class="level" id="levelDisplay">Level 1 / 100</div></div>

  <div id="sideHud">
    <div class="chip" id="coinChip">Coins: 0</div>
    <div class="chip" id="progressChip">Unlocked: 1</div>
  </div>

  <div id="legend">
    Legend:
    <div style="display:flex; gap:8px; margin-top:6px; flex-wrap:wrap;">
      <div style="width:12px;height:12px;background:#CDE8FF;border-radius:3px;"></div><div style="font-size:12px">Normal</div>
      <div style="width:12px;height:12px;background:#D8C6FF;border-radius:3px;margin-left:6px"></div><div style="font-size:12px">Moving</div>
      <div style="width:12px;height:12px;background:#C8FFD0;border-radius:3px;margin-left:6px"></div><div style="font-size:12px">Boost</div>
      <div style="width:12px;height:12px;background:#FFCCCC;border-radius:3px;margin-left:6px"></div><div style="font-size:12px">Spike</div>
      <div style="width:12px;height:12px;background:#FFE3BF;border-radius:3px;margin-left:6px"></div><div style="font-size:12px">Breaking</div>
    </div>
  </div>

  <div id="controls">‚Üê/A ‚Üí/D = move ‚Ä¢ Space = jump ‚Ä¢ P = pause ‚Ä¢ R = restart</div>

  <div id="menu" class="menu">
    <h1 id="menuTitle">‚ú® Cute Platformer ‚ú®</h1>
    <p id="menuDesc">100 playable levels ‚Äî now with guaranteed reachability, visible spikes, jump-boost platforms, moving and breaking platforms, and persistent progress saved locally.</p>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button id="startBtn" class="btn primary">Start (Space)</button>
      <button id="openSelectBtn" class="btn alt">Level Select</button>
      <button id="resetProgressBtn" class="btn" style="background:linear-gradient(180deg,#FFBDBD,#FF8A8A)">Reset Progress</button>
    </div>

    <div id="levelSelect" style="display:none; margin-top:10px; width:760px; max-width:95%;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:700;">Level Select</div>
        <div><button id="closeSelectBtn" class="btn alt">Close</button></div>
      </div>
      <div id="levelSelectGrid"></div>
    </div>

    <p style="font-size:13px; opacity:0.9; margin-top:6px">If a level feels too hard, you can select any unlocked level from the Level Select. Progress is saved automatically.</p>
  </div>
</div>

<script>
/* Complete single-file platformer.
   Key improvements:
   - Conservative reachable-gap calculation + placement retries to avoid impossible levels.
   - Spike platforms drawn and functional.
   - Jump boost platforms visually clear and actually increase jump when jumping.
   - Moving platforms constrained to remain reachable.
   - Breaking platforms disappear after stepping.
   - Local storage save of highestUnlocked and totalCoins.
   - Level select UI shows unlocked levels.
   - Particle pops for coins / break / boost.
*/

/* ---------------------------
   Configuration
   --------------------------- */
const LEVEL_COUNT = 100;
const BASE_LEVEL_WIDTH = 1100;
const EXTRA_WIDTH_PER_LEVEL = 40;

const PLAYER_CONFIG = {
  w: 40, h: 52,
  speedAccel: 0.36,
  maxSpeed: 6.3,    // px/frame (approx)
  jumpStrength: 11.6, // initial upward velocity (px/frame)
  gravity: 0.5,     // px/frame^2
  coyoteTime: 140,  // ms
  jumpBuffer: 140   // ms
};

const PROB_BASE = {
  moving: 0.08,
  boost: 0.06,
  spike: 0.06,
  breaking: 0.06
};

const MOVING_SPEED_RANGE = [0.6, 2.2]; // px/frame
const MOVING_RANGE_MIN = 60;
const BREAK_DELAY_MS = 420;
const COIN_BASE = 6;

/* ---------------------------
   Persistence
   --------------------------- */
const STORAGE_KEY = 'cute_platformer_save_v2';
function loadSave(){
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return { highestUnlocked:1, totalCoins:0 };
    const p = JSON.parse(raw);
    return { highestUnlocked: Math.max(1, Math.min(LEVEL_COUNT, p.highestUnlocked||1)), totalCoins: p.totalCoins||0 };
  } catch {
    return { highestUnlocked:1, totalCoins:0 };
  }
}
function saveProgress(state){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}
function resetProgress() {
  localStorage.removeItem(STORAGE_KEY);
  save = { highestUnlocked:1, totalCoins:0 };
  applySaveUI();
}

/* ---------------------------
   Canvas & UI nodes
   --------------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
window.addEventListener('resize', ()=>{
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  camera.x = Math.max(0, player.x - W*0.35);
});

const levelDisplay = document.getElementById('levelDisplay');
const coinChip = document.getElementById('coinChip');
const progressChip = document.getElementById('progressChip');
const menuEl = document.getElementById('menu');
const startBtn = document.getElementById('startBtn');
const openSelectBtn = document.getElementById('openSelectBtn');
const resetProgressBtn = document.getElementById('resetProgressBtn');
const levelSelect = document.getElementById('levelSelect');
const closeSelectBtn = document.getElementById('closeSelectBtn');
const levelSelectGrid = document.getElementById('levelSelectGrid');
const menuTitle = document.getElementById('menuTitle');
const menuDesc = document.getElementById('menuDesc');

/* ---------------------------
   State
   --------------------------- */
let save = loadSave();
let currentLevelIndex = Math.max(0, Math.min(LEVEL_COUNT-1, save.highestUnlocked-1));
let levels = []; // generated configs
let level = null; // working copy
let running = false;
let paused = false;
let lastFrame = performance.now();
let coinsThisLevel = 0;

/* ---------------------------
   Player and camera
   --------------------------- */
const player = {
  x: 120, y: H - 220, w: PLAYER_CONFIG.w, h: PLAYER_CONFIG.h,
  vx: 0, vy: 0,
  speedAccel: PLAYER_CONFIG.speedAccel,
  maxSpeed: PLAYER_CONFIG.maxSpeed,
  jumpStrength: PLAYER_CONFIG.jumpStrength, gravity: PLAYER_CONFIG.gravity,
  onGround: false, facing: 1, coyoteTimer: 0, jumpBufferTimer: 0,
  coyoteTime: PLAYER_CONFIG.coyoteTime, jumpBuffer: PLAYER_CONFIG.jumpBuffer
};

const camera = { x:0, y:0 };

/* ---------------------------
   Input
   --------------------------- */
const keys = {};
window.addEventListener('keydown', (e)=> {
  keys[e.key.toLowerCase()] = true;
  if (!running && e.key === ' ') startGame();
  if (e.key === 'p') paused = !paused;
  if (e.key === 'r' && running) restartLevel();
});
window.addEventListener('keyup', (e)=> keys[e.key.toLowerCase()] = false);

/* ---------------------------
   Utility helpers
   --------------------------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function randRange(a,b){ return a + Math.random() * (b-a); }
function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

/* ---------------------------
   Level generator ‚Äî Guarantees reachability
   - conservative horizontal reach calculation
   - retries placement for each platform until it is reachable
   - if it cannot place after many attempts, reduce gap/height to make it reachable
   --------------------------- */
function computeConservativeMaxGap() {
  // Use an approximation for horizontal reachable distance during a jump:
  // airtimeFrames ‚âà 2 * jumpStrength / gravity
  // horizontal reach ‚âà maxSpeed * airtimeFrames
  const frames = 2 * PLAYER_CONFIG.jumpStrength / PLAYER_CONFIG.gravity;
  const reach = PLAYER_CONFIG.maxSpeed * frames;
  // use a conservative factor (0.78) and clamp to reasonable min/max
  return Math.round(clamp(reach * 0.78, 140, 700));
}

function generateLevels() {
  levels.length = 0;
  for (let i=0;i<LEVEL_COUNT;i++){
    const difficulty = i / (LEVEL_COUNT-1);
    const width = Math.round(BASE_LEVEL_WIDTH + i * EXTRA_WIDTH_PER_LEVEL + Math.random()*360);
    const baseY = H - 80;

    const platforms = [];
    // start platform
    platforms.push({ x:0, y: baseY - 18, w: Math.min(600, 260 + Math.round(200 - difficulty*120)), h:20, type:'normal' });

    const conservativeMaxGap = computeConservativeMaxGap();
    // cap vertical move so levels don't stack too high
    const maxVerticalStep = Math.round(220 + difficulty * 120);

    let cursor = 300;
    const segments = 7 + Math.round(difficulty * 16);

    for (let seg=0; seg<segments && cursor < width - 260; seg++){
      const pCount = 1 + Math.floor(Math.random()*2);
      for (let p=0;p<pCount && cursor < width - 200; p++){
        // choose type with mild difficulty progression
        let type = 'normal';
        const r = Math.random();
        const movingChance = PROB_BASE.moving + difficulty*0.08;
        const boostChance = PROB_BASE.boost + difficulty*0.04;
        const spikeChance = PROB_BASE.spike + difficulty*0.05;
        const breakingChance = PROB_BASE.breaking + difficulty*0.05;

        if (r < movingChance) type = 'moving';
        else if (r < movingChance + boostChance) type = 'boost';
        else if (r < movingChance + boostChance + spikeChance) type = 'spike';
        else if (r < movingChance + boostChance + spikeChance + breakingChance) type = 'breaking';

        // try placing this platform with retries until reachable from last placed platform
        let attempts = 0;
        let placed = false;
        let px=0, py=0, pw=0;
        const prev = platforms[platforms.length-1];
        while (!placed && attempts < 160) {
          attempts++;
          // choose a gap that is usually less than conservativeMaxGap, but sometimes allow larger if type is boost and we'll place boost to allow jump
          // choose gap baseline
          let gap = 80 + Math.round(Math.random() * Math.max(80, conservativeMaxGap - 80));
          // occasionally reduce gap for easier traversal
          if (Math.random() < 0.18) gap = Math.round(gap * (0.6 + Math.random()*0.6));

          // width of platform
          pw = 80 + Math.round(Math.random() * (120 + difficulty * 80));
          px = cursor + gap;
          // vertical position attempt
          const yVariation = Math.round(Math.random() * (maxVerticalStep));
          py = Math.max(120, Math.min(baseY - 20, prev.y - Math.round(60 - Math.random()*120) + yVariation - (Math.random()*60)));

          // compute horizontal difference and vertical difference
          const dx = px - (prev.x + prev.w);
          const dy = Math.abs(py - prev.y);

          // If dx <= conservativeMaxGap it's likely reachable. If it's bigger:
          // - allow if previous platform is boost and type is normal (player can jump farther)
          // - or if this platform is boost and dx is slightly bigger (we place boost to allow jump from prev)
          // otherwise reduce gap and continue
          if (dx <= conservativeMaxGap) {
            placed = true;
            break;
          } else {
            // allow special case: if either prev or current is boost and dx <= conservativeMaxGap * 1.20
            if ((prev && prev.type === 'boost') && dx <= conservativeMaxGap * 1.22) { placed = true; break; }
            if ((type === 'boost') && dx <= conservativeMaxGap * 1.22) { placed = true; break; }
            // if moving platform, ensure its range can bring it closer later ‚Äî but keep guaranteed by limiting range later
            // otherwise reduce gap a bit and retry
            gap = Math.max(80, Math.round(gap * 0.7));
            cursor -= Math.round((Math.random()*20)); // a small nudge back to avoid runaway
            // Also as last resort: clamp px to be reachable
            if (attempts > 100) {
              px = prev.x + prev.w + Math.round(conservativeMaxGap * (0.9 + Math.random()*0.05));
              placed = true; break;
            }
          }
        } // attempts loop

        // finalize type-specific properties
        const plat = { x: px, y: py, w: pw, h: 18, type };
        if (type === 'moving') {
          // choose axis, set range such that platform endpoint remains within conservative reach from prev
          if (Math.random() < 0.76) {
            // horizontal movement but keep startX such that moving will not create unreachable spots
            const range = Math.round(MOVING_RANGE_MIN + Math.random()*Math.max(80, conservativeMaxGap*0.28 + difficulty*120));
            plat.moving = { axis:'x', range: range, speed: randRange(MOVING_SPEED_RANGE[0], MOVING_SPEED_RANGE[1]) * (1 + difficulty*0.18) };
          } else {
            const range = Math.round(MOVING_RANGE_MIN/2 + Math.random()*100 + difficulty*80);
            plat.moving = { axis:'y', range: range, speed: randRange(MOVING_SPEED_RANGE[0], MOVING_SPEED_RANGE[1]) * (1 + difficulty*0.16) };
          }
          plat.startX = plat.x; plat.startY = plat.y; plat._dir = 1; plat._offset = 0;
        } else if (type === 'breaking') {
          plat.breaking = { stepping:false, timer:0 }; plat._gone = false;
        } else if (type === 'boost') {
          plat.boost = { multiplier: 1.45 + Math.random()*0.35 };
        }
        platforms.push(plat);
        cursor = px + pw + 20;
      } // pCount
      cursor += 200 + Math.round(Math.random() * (120 + difficulty * 420));
    } // segments

    // final large platform / goal ‚Äî must be reachable from previous platform
    let lastPlat = platforms[platforms.length-1];
    let finalX = Math.max(cursor + 100, width - 360);
    let finalY = Math.max(120, Math.min(baseY - 20, lastPlat.y - 10 - Math.round(difficulty * 120)));
    // ensure finalX is reachable ‚Äî adjust if needed
    const dxFinal = finalX - (lastPlat.x + lastPlat.w);
    if (dxFinal > computeConservativeMaxGap()) {
      // if too far, attempt to insert a boost platform before final
      const boostX = lastPlat.x + lastPlat.w + Math.round(computeConservativeMaxGap() * 0.6);
      platforms.push({ x: boostX, y: lastPlat.y - Math.round(30 + Math.random()*40), w: 140, h:18, type:'boost', boost:{multiplier:1.55} });
      finalX = boostX + 220;
      finalY = Math.max(120, Math.min(baseY - 20, platforms[platforms.length-1].y - 40));
    }
    // final platform
    const finalPlat = { x: finalX, y: finalY, w: 240, h:22, type:'normal' };
    platforms.push(finalPlat);

    // coins (scattered)
    const coins = [];
    const coinCount = COIN_BASE + Math.round(difficulty * 10);
    for (let c=0;c<coinCount;c++){
      const p = platforms[Math.floor(Math.random()*platforms.length)];
      const cx = p.x + 16 + Math.random() * Math.max(20, p.w - 32);
      const cy = p.y - 26 - Math.random()*40;
      coins.push({ x: cx, y: cy, r: 8, collected:false });
    }

    const star = { x: finalPlat.x + finalPlat.w/2, y: finalPlat.y - 44, r: 18 };
    // store level
    levels.push({ platforms, coins, star, width: Math.max(width, finalPlat.x + finalPlat.w + 100), baseY });
  } // level loop
} // generateLevels

generateLevels();

/* ---------------------------
   Deep-copy load for play
   --------------------------- */
function loadLevel(index) {
  currentLevelIndex = clamp(index, 0, LEVEL_COUNT-1);
  level = JSON.parse(JSON.stringify(levels[currentLevelIndex]));
  // re-init runtime fields
  for (const p of level.platforms) {
    if (p.moving) { p.x = p.startX; p.y = p.startY; p._dir = 1; p._offset = 0; }
    if (p.breaking) { p.breaking.stepping = false; p.breaking.timer = 0; p._gone = false; }
  }
  level.coins.forEach(c => c.collected = false);
  player.x = 120; player.y = H - 220; player.vx = 0; player.vy = 0; player.onGround = false; player.coyoteTimer = 0; player.jumpBufferTimer = 0;
  coinsThisLevel = 0;
  camera.x = 0;
  updateHUD();
}

/* ---------------------------
   HUD & UI helpers
   --------------------------- */
function applySaveUI(){
  progressChip.textContent = 'Unlocked: ' + (save.highestUnlocked || 1);
  coinChip.textContent = 'Coins: ' + ( (save.totalCoins||0) + coinsThisLevel );
}
function updateHUD(){
  levelDisplay.textContent = `Level ${currentLevelIndex + 1} / ${LEVEL_COUNT}`;
  coinChip.textContent = 'Coins: ' + ( (save.totalCoins||0) + coinsThisLevel );
  progressChip.textContent = 'Unlocked: ' + (save.highestUnlocked || 1);
}

/* ---------------------------
   Collision & physics helpers
   --------------------------- */
function rectIntersects(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}
function resolveCollision(px,py,pw,ph,plat){
  const p = {x:px,y:py,w:pw,h:ph};
  const q = {x:plat.x,y:plat.y,w:plat.w,h:plat.h};
  if (!rectIntersects(p,q)) return null;
  const ox1 = (p.x + p.w) - q.x;
  const ox2 = (q.x + q.w) - p.x;
  const oy1 = (p.y + p.h) - q.y;
  const oy2 = (q.y + q.h) - p.y;
  const m = Math.min(ox1,ox2,oy1,oy2);
  if (m === oy1) return { side:'top', y: q.y - p.h };
  if (m === oy2) return { side:'bottom', y: q.y + q.h };
  if (m === ox1) return { side:'left', x: q.x - p.w };
  return { side:'right', x: q.x + q.w };
}

/* ---------------------------
   Particles (tiny visual polish)
   --------------------------- */
const particles = [];
function spawnParticles(x,y,color,count=8){
  for (let i=0;i<count;i++){
    particles.push({
      x,y,
      vx: randRange(-1.6,1.6), vy: randRange(-3.2,-0.6),
      life: 420 + Math.random()*220, color,
      size: 2 + Math.random()*3
    });
  }
}
function updateParticles(dt){
  for (let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.life -= dt;
    if (p.life <= 0) { particles.splice(i,1); continue; }
    p.vy += 0.06 * (dt/16.67);
    p.x += p.vx * (dt/16.67);
    p.y += p.vy * (dt/16.67);
  }
}

/* ---------------------------
   Game update loop
   --------------------------- */
function startGame(){
  // clamp to unlocked
  if (currentLevelIndex + 1 > save.highestUnlocked) currentLevelIndex = save.highestUnlocked - 1;
  loadLevel(currentLevelIndex);
  running = true; paused = false;
  menuEl.style.display = 'none';
  lastFrame = performance.now();
  requestAnimationFrame(loop);
}
function restartLevel(){ loadLevel(currentLevelIndex); running=true; paused=false; menuEl.style.display='none'; }
function goToMenu(title,msg){
  running=false; paused=false; menuEl.style.display='flex'; menuTitle.textContent = title; menuDesc.textContent = msg;
  buildLevelSelectGrid();
}

function loop(now){
  if (!running) return;
  const dt = Math.min(40, now - lastFrame);
  lastFrame = now;
  if (!paused) update(dt);
  draw();
  if (running) requestAnimationFrame(loop);
}

function update(dt){
  // input
  const left = keys['arrowleft'] || keys['a'];
  const right = keys['arrowright'] || keys['d'];
  const jumpKey = keys[' '] || keys['spacebar'];

  // horizontal accel & friction
  const acc = player.speedAccel * dt;
  if (left) player.vx -= acc, player.facing = -1;
  if (right) player.vx += acc, player.facing = 1;
  if (!left && !right) player.vx *= 0.86;
  player.vx = clamp(player.vx, -player.maxSpeed, player.maxSpeed);

  // gravity
  player.vy += player.gravity * (dt / 16.67);

  // jump buffer & coyote
  if (jumpKey) player.jumpBufferTimer = player.jumpBuffer;
  else player.jumpBufferTimer = Math.max(0, player.jumpBufferTimer - dt);
  player.coyoteTimer = Math.max(0, player.coyoteTimer - dt);

  // attempt jump (we'll check boost platform multiplier just before jump)
  // If buffered and on ground or coyote
  let standingOn = null;
  // move integration first
  player.x += player.vx;
  player.y += player.vy;

  // bounds clamp x
  if (player.x < -40) player.x = -40;
  if (player.x > level.width - player.w + 40) player.x = level.width - player.w + 40;

  // update moving platforms before collision checks
  for (const p of level.platforms){
    if (p._gone) continue;
    if (p.type === 'moving' && p.moving){
      if (p.moving.axis === 'x') {
        p._offset = (p._offset || 0) + p.moving.speed * p._dir;
        p.x = p.startX + p._offset;
        if (Math.abs(p._offset) >= p.moving.range) p._dir *= -1;
      } else {
        p._offset = (p._offset || 0) + p.moving.speed * p._dir;
        p.y = p.startY + p._offset;
        if (Math.abs(p._offset) >= p.moving.range) p._dir *= -1;
      }
    }
    // breaking timers
    if (p.type === 'breaking' && p.breaking && p.breaking.timer > 0) {
      p.breaking.timer -= dt;
      if (p.breaking.timer <= 0) p._gone = true;
    }
  }

  // collisions
  player.onGround = false;
  for (const p of level.platforms){
    if (p._gone) continue;
    const res = resolveCollision(player.x, player.y, player.w, player.h, p);
    if (!res) continue;
    if (res.side === 'top'){
      player.y = res.y; player.vy = 0; player.onGround = true; standingOn = p; player.coyoteTimer = player.coyoteTime;
      // stick to moving platform a bit so player moves with it
      if (p.type === 'moving' && p.moving && p.moving.axis === 'x') {
        player.x += p.moving.speed * p._dir * (1); // approximate carry
      }
      // breaking: start timer
      if (p.type === 'breaking' && p.breaking && !p.breaking.stepping) {
        p.breaking.stepping = true; p.breaking.timer = BREAK_DELAY_MS;
      }
      // spike on top -> death
      if (p.type === 'spike') {
        goToMenu('Ouch ‚Äî spike!', 'You touched spikes. Back to menu.');
        return;
      }
    } else if (res.side === 'bottom') {
      player.y = res.y; player.vy = Math.max(0, player.vy);
    } else if (res.side === 'left') {
      player.x = res.x; player.vx = Math.min(0, player.vx);
    } else {
      player.x = res.x; player.vx = Math.max(0, player.vx);
    }
  }

  // Apply boost effect: if player is on a boost platform and jump occurs, multiply jump strength
  const effectiveJumpStrength = (standingOn && standingOn.type === 'boost' && standingOn.boost) ? (PLAYER_CONFIG.jumpStrength * standingOn.boost.multiplier) : PLAYER_CONFIG.jumpStrength;
  // Now attempt jump
  if (player.jumpBufferTimer > 0 && (player.onGround || player.coyoteTimer > 0)) {
    player.vy = -effectiveJumpStrength;
    player.onGround = false;
    player.coyoteTimer = 0;
    player.jumpBufferTimer = 0;
    // small particle effect for boost feedback
    if (standingOn && standingOn.type === 'boost') spawnParticles(player.x + player.w/2, player.y + player.h, '#9DF7A8', 12);
  }

  // collect coins
  for (const c of level.coins){
    if (c.collected) continue;
    const dx = (player.x + player.w/2) - c.x;
    const dy = (player.y + player.h/2) - c.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d < c.r + Math.max(player.w, player.h)/3) {
      c.collected = true;
      coinsThisLevel++;
      save.totalCoins = (save.totalCoins || 0) + 1;
      saveProgress(save);
      spawnParticles(c.x, c.y, '#FFD66B', 10);
      updateHUD();
    }
  }

  // star / goal
  const star = level.star;
  const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
  const starRect = { x: star.x - star.r, y: star.y - star.r, w: star.r*2, h: star.r*2 };
  if (rectIntersects(playerRect, starRect)) {
    // unlock next level if necessary
    if (save.highestUnlocked < currentLevelIndex + 2) {
      save.highestUnlocked = Math.min(LEVEL_COUNT, currentLevelIndex + 2);
    }
    saveProgress(save);
    applySaveUI();
    // next level or finished
    if (currentLevelIndex < LEVEL_COUNT - 1) {
      currentLevelIndex++;
      loadLevel(currentLevelIndex);
    } else {
      goToMenu('You cleared all levels! üéâ', 'Amazing ‚Äî you finished all levels.');
    }
    return;
  }

  // spike side collisions (touching from side)
  for (const p of level.platforms){
    if (p.type === 'spike') {
      const spikeRect = { x: p.x, y: p.y - 4, w: p.w, h: p.h + 6 };
      if (rectIntersects(playerRect, spikeRect)) {
        goToMenu('Ouch ‚Äî spike!', 'You touched spikes. Back to menu.');
        return;
      }
    }
  }

  // falling off
  if (player.y > H + 160) {
    goToMenu('You fell! üòø', 'You fell from the level. Back to the menu.');
    return;
  }

  // camera smoothing
  const targetCamX = Math.max(0, player.x - W*0.35);
  camera.x += (targetCamX - camera.x) * 0.12;

  updateParticles(dt);
  updateHUD();
}

/* ---------------------------
   Drawing code
   --------------------------- */
function drawRoundedRect(x,y,w,h,r=10){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }
function drawStar(cx,cy,r,spikes=6){ ctx.save(); ctx.beginPath(); const outer=r, inner=r*0.5; let rot=Math.PI/2*3; let x=cx,y=cy; const step=Math.PI/spikes; ctx.moveTo(cx,cy-outer); for(let i=0;i<spikes;i++){ x=cx+Math.cos(rot)*outer; y=cy+Math.sin(rot)*outer; ctx.lineTo(x,y); rot+=step; x=cx+Math.cos(rot)*inner; y=cy+Math.sin(rot)*inner; ctx.lineTo(x,y); rot+=step;} ctx.closePath(); ctx.fill(); ctx.restore(); }
function drawCoin(x,y,r){ ctx.beginPath(); ctx.ellipse(x,y,r*1.1,r,0,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1; ctx.stroke(); ctx.strokeStyle='transparent'; }

function draw(){
  // background
  ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#FFF4F9'); g.addColorStop(0.6,'#F7FBFF'); g.addColorStop(1,'#E7F7FF');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // hills
  const hillColors = ['#FDECF7','#E9E9FF','#DDF6F8'];
  for (let i=0;i<3;i++){
    ctx.fillStyle = hillColors[i];
    ctx.beginPath();
    const amp = 80 + i*30;
    ctx.moveTo(-200, H*0.85 - i*40);
    for (let x=-200; x<=W+400; x+=60){
      const y = H*0.85 - i*40 - Math.sin((x*0.003)+i)*amp;
      ctx.lineTo(x,y);
    }
    ctx.lineTo(W+400,H+200); ctx.lineTo(-200,H+200); ctx.closePath(); ctx.fill();
  }
  // ground band
  ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.fillRect(0,H-120,W,120);

  // camera transform
  ctx.save(); ctx.translate(-Math.round(camera.x), 0);

  // platforms
  for (const p of level.platforms){
    if (p._gone) continue;
    let color='#CDE8FF';
    if (p.type==='moving') color='#D8C6FF';
    if (p.type==='boost') color='#C8FFD0';
    if (p.type==='spike') color='#FFCCCC';
    if (p.type==='breaking') color='#FFE3BF';
    ctx.fillStyle = color;
    drawRoundedRect(p.x, p.y, p.w, p.h, 10);
    // shine
    ctx.fillStyle='rgba(255,255,255,0.12)'; drawRoundedRect(p.x+6, p.y+2, Math.max(0,p.w-12), 6, 6);
    // special visuals
    if (p.type==='spike') {
      const spikeCount = Math.max(3, Math.round(p.w/26));
      ctx.fillStyle = '#FF5A5A';
      for (let s=0;s<spikeCount;s++){
        const sx = p.x + 6 + (p.w - 12) * (s / Math.max(1,spikeCount-1));
        const sw = Math.min(18, (p.w-12) / spikeCount);
        ctx.beginPath(); ctx.moveTo(sx - sw/2, p.y + p.h); ctx.lineTo(sx, p.y + p.h - Math.min(22, sw*1.2)); ctx.lineTo(sx + sw/2, p.y + p.h); ctx.closePath(); ctx.fill();
      }
    } else if (p.type==='moving' && p.moving) {
      ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font='12px Arial';
      if (p.moving.axis==='x') ctx.fillText('‚áÑ', p.x + p.w - 20, p.y + p.h - 6); else ctx.fillText('‚áÖ', p.x + p.w - 20, p.y + p.h - 6);
    } else if (p.type==='boost') {
      ctx.fillStyle='rgba(20,200,120,0.9)'; ctx.beginPath(); ctx.arc(p.x + 16, p.y + p.h/2, 8, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='white'; ctx.font='12px Arial'; ctx.fillText('‚Üë', p.x + 12, p.y + p.h/2 + 4);
    } else if (p.type==='breaking' && p.breaking && p.breaking.stepping) {
      const frac = Math.max(0, Math.min(1, p.breaking.timer / BREAK_DELAY_MS));
      ctx.fillStyle = `rgba(210,80,20,${1-frac})`; drawRoundedRect(p.x, p.y, p.w, p.h, 10);
    }
  }

  // coins
  for (const c of level.coins){
    if (c.collected) continue;
    ctx.fillStyle = '#FFD66B'; drawCoin(c.x, c.y, c.r);
    ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.ellipse(c.x - c.r*0.18, c.y - c.r*0.28, c.r*0.26, c.r*0.09, 0, 0, Math.PI*2); ctx.fill();
  }

  // star
  ctx.save();
  ctx.translate(level.star.x, level.star.y);
  const spin = (performance.now() / 500) % (Math.PI*2);
  ctx.rotate(spin);
  ctx.fillStyle = '#FFF59A'; drawStar(0,0,level.star.r,6);
  ctx.fillStyle = '#FFD54A'; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // player
  ctx.fillStyle = '#FFD28A'; drawRoundedRect(player.x, player.y, player.w, player.h, 10);
  ctx.fillStyle = '#2B2B2B'; ctx.beginPath(); ctx.ellipse(player.x + player.w*0.32, player.y + player.h*0.36, 3.8, 5.2, 0, 0, Math.PI*2); ctx.ellipse(player.x + player.w*0.68, player.y + player.h*0.36, 3.8, 5.2, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = 'rgba(255,105,135,0.12)'; ctx.beginPath(); ctx.ellipse(player.x + player.w*0.2, player.y + player.h*0.6, 8, 4, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(player.x + player.w*0.8, player.y + player.h*0.6, 8, 4, 0, 0, Math.PI*2); ctx.fill();

  // particles
  for (const p of particles){
    ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life/600);
    ctx.fillRect(p.x, p.y, p.size, p.size);
    ctx.globalAlpha = 1;
  }

  ctx.restore();

  // paused overlay
  if (paused) {
    ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.font='44px Poppins, Arial'; ctx.textAlign='center'; ctx.fillText('PAUSED', W/2, H/2 - 8);
    ctx.font='14px Arial'; ctx.fillText('Press P to resume', W/2, H/2 + 22);
  }
}

/* ---------------------------
   Level select UI builder
   --------------------------- */
function buildLevelSelectGrid(){
  levelSelectGrid.innerHTML = '';
  for (let i=0;i<LEVEL_COUNT;i++){
    const btn = document.createElement('div');
    btn.className = 'levelButton';
    btn.textContent = i+1;
    if (i+1 > (save.highestUnlocked || 1)) btn.classList.add('locked');
    else btn.addEventListener('click', ()=> { currentLevelIndex = i; startGame(); });
    levelSelectGrid.appendChild(btn);
  }
}

/* ---------------------------
   Start / restart handlers & init
   --------------------------- */
startBtn.addEventListener('click', ()=> startGame());
openSelectBtn.addEventListener('click', ()=> { levelSelect.style.display = levelSelect.style.display === 'flex' ? 'none' : 'flex'; });
closeSelectBtn.addEventListener('click', ()=> levelSelect.style.display = 'none');
resetProgressBtn.addEventListener('click', ()=> {
  if (confirm('Reset saved progress? This unlocks only level 1 and clears coins.')) {
    resetProgress();
    buildLevelSelectGrid();
    applySaveUI();
    menuTitle.textContent = '‚ú® Cute Platformer ‚ú®';
    menuDesc.textContent = 'Progress reset. Press Start to play.';
  }
});

function restartLevel(){ loadLevel(currentLevelIndex); running=true; paused=false; menuEl.style.display='none'; }
function goToMenuWithMsg(title,msg){ running=false; paused=false; menuEl.style.display='flex'; menuTitle.textContent = title; menuDesc.textContent = msg; buildLevelSelectGrid(); }

/* init UI & ready */
applySaveUI(); buildLevelSelectGrid();
menuEl.style.display = 'flex';
menuTitle.textContent = '‚ú® Cute Platformer ‚ú®';
menuDesc.textContent = '100 playable levels ‚Äî reach the star to unlock the next level. Progress is saved locally.';

/* debug: auto start: uncomment to test quickly */
// startGame();

</script>
</body>
</html>
