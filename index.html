<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cute Platformer — 100 Levels</title>
<style>
  html,body { height:100%; margin:0; background: linear-gradient(180deg,#FFFAF0,#F3E8FF); font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #gameCanvas { display:block; width:100vw; height:100vh; background: transparent; }
  #overlay {
    position: absolute; left:0; top:0; right:0; bottom:0; pointer-events:none;
  }
  .menu {
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    background: rgba(10,10,20,0.25); backdrop-filter: blur(6px);
    color:#fff; flex-direction:column; gap:14px; pointer-events:auto;
  }
  .menu h1 { margin:0; font-size:38px; letter-spacing:1px; color:#fff; text-shadow: 0 3px 10px rgba(0,0,0,0.35); }
  .menu p { margin:0; color:#f0f0f0; opacity:0.9; }
  .btn {
    background: linear-gradient(180deg,#FFD6E0,#FF9CCC); border:0; padding:12px 22px;
    font-size:18px; border-radius:12px; cursor:pointer; box-shadow: 0 6px 20px rgba(0,0,0,0.18);
  }
  #hud {
    position:absolute; left:0; right:0; top:8px; display:flex; justify-content:center; pointer-events:none;
  }
  #hud .level {
    font-size:42px; color:#212; text-shadow: 0 3px 8px rgba(255,255,255,0.6); font-weight:700;
    background: rgba(255,255,255,0.75); padding:8px 18px; border-radius:18px;
  }
  #smallHud {
    position:absolute; top:12px; left:16px; font-size:16px; color:#333; background:rgba(255,255,255,0.9);
    padding:8px 12px; border-radius:10px; pointer-events:none;
  }
  #instructions {
    position:absolute; bottom:16px; left:50%; transform:translateX(-50%); color:#222; background:rgba(255,255,255,0.9);
    padding:8px 12px; border-radius:12px; font-size:14px;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="overlay">
  <div id="hud"><div class="level" id="levelDisplay">Level 1 / 100</div></div>
  <div id="smallHud">Coins: <span id="coinCount">0</span></div>

  <div id="menu" class="menu" style="display:flex; gap:12px; pointer-events:auto;">
    <h1>✨ Cute Platformer ✨</h1>
    <p>100 tiny levels — reach the star to advance. Controls: ← → (or A/D) + Space to jump.</p>
    <div style="display:flex; gap:10px;">
      <button id="startBtn" class="btn">Start (Space)</button>
      <button id="levelSelectBtn" class="btn" style="background:linear-gradient(180deg,#D7F0FF,#A9E0FF)">Level Select</button>
    </div>
    <p style="font-size:13px; opacity:0.9">P = Pause • R = Restart level • Fall to return to menu</p>
  </div>

  <div id="instructions">Hold keys for smooth movement — enjoy!</div>
</div>

<script>
/* Cute Platformer — 100 Levels
   Single HTML file. Controls: ←/→ or A/D, Space to jump. P pause, R restart, Space or Start button to begin.
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;

window.addEventListener('resize', () => {
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  camera.x = Math.max(0, player.x - W * 0.35);
  camera.y = 0;
});

/// ----------------------------
// Game state
let running = false;
let paused = false;
let currentLevelIndex = 0; // 0-based index -> level 1 = index 0
let coinsCollected = 0;

// HUD elements
const menuEl = document.getElementById('menu');
const levelDisplay = document.getElementById('levelDisplay');
const coinCount = document.getElementById('coinCount');
const startBtn = document.getElementById('startBtn');
const levelSelectBtn = document.getElementById('levelSelectBtn');

// Input
const keys = {};

// Controls
window.addEventListener('keydown', (e) => {
  const k = e.key.toLowerCase();
  keys[k] = true;
  if (!running && (e.key === ' ')) startGame();
  if (e.key === 'p') paused = !paused;
  if (e.key === 'r' && running) restartLevel();
});
window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

// Start / menu
startBtn.addEventListener('click', () => startGame());
levelSelectBtn.addEventListener('click', openLevelSelect);

function openLevelSelect(){
  const pick = prompt("Jump to level (1 - 100):", (currentLevelIndex+1));
  if (!pick) return;
  const n = Math.max(1, Math.min(100, parseInt(pick || "1", 10)));
  currentLevelIndex = n - 1;
  startGame();
}

// ---------------------------
// World generation & levels

// Level format: { platforms: [{x,y,w,h}], star: {x,y,r}, coins: [{x,y}], width }
// We'll generate progressively harder levels procedurally.
const LEVEL_COUNT = 100;
const levels = [];

function generateLevels() {
  levels.length = 0;
  for (let i=0;i<LEVEL_COUNT;i++){
    const difficulty = i / (LEVEL_COUNT - 1); // 0..1
    const width = Math.round(1200 + difficulty * 4800); // level length in pixels
    const groundHeight = 80;
    const baseY = H - groundHeight;

    let platforms = [];
    // start platform
    platforms.push({ x: 0, y: baseY - 20, w: Math.min(600, 250 + Math.round(350 - difficulty*150)), h: 24 });

    // generate platform clusters
    let x = 300;
    const segments = 8 + Math.round(difficulty * 14); // more segments for higher levels
    for (let seg=0; seg<segments && x < width - 200; seg++){
      // platform count per segment
      const pCount = 1 + Math.floor(Math.random()*2);
      for (let p=0;p<pCount;p++){
        const gap = 80 + Math.round(Math.random() * (150 + difficulty*220));
        const w = 80 + Math.round(Math.random() * (120 + difficulty*80));
        const maxRise = Math.round(180 + difficulty * 220);
        // vary y with some randomness, but keep within reasonable bounds
        const y = baseY - 20 - Math.round(Math.random() * maxRise) - Math.round(Math.sin((x + p*50) / 200) * 40);
        platforms.push({ x: x + gap * p, y: Math.max(140, Math.min(baseY - 20, y)), w, h: 18 });
      }
      x += 300 + Math.round(Math.random() * (200 + difficulty * 400));
    }

    // final platform near the end to place star/goal
    const finalW = 220;
    const finalX = Math.max(x + 100, width - 350);
    platforms.push({ x: finalX, y: baseY - 60 - Math.round(difficulty * 160), w: finalW, h: 22 });

    // coins scattered
    const coins = [];
    for (let c=0;c<6 + Math.round(difficulty * 10); c++){
      // pick a random platform to place coin above
      const p = platforms[Math.floor(Math.random() * platforms.length)];
      const cx = p.x + 20 + Math.random()*(p.w-40);
      const cy = p.y - 26 - Math.random()*36;
      coins.push({x: cx, y: cy, r: 8, collected: false});
    }

    // star/goal position
    const lastPlatform = platforms[platforms.length - 1];
    const star = { x: lastPlatform.x + lastPlatform.w/2, y: lastPlatform.y - 44, r: 18 };

    levels.push({ platforms, star, coins, width: Math.max(width, finalX + finalW + 200), baseY });
  }
}

// call once
generateLevels();

// ---------------------------
// Player and physics

const player = {
  x: 120,
  y: H - 180,
  w: 40,
  h: 52,
  vx: 0,
  vy: 0,
  speed: 0.36, // acceleration per ms
  maxSpeed: 6.5,
  jumpStrength: 11.8,
  onGround: false,
  facing: 1,
  color: '#FFD28A',
  coyoteTime: 140, // ms
  coyoteTimer: 0,
  jumpBuffer: 140, // ms
  jumpBufferTimer: 0
};

const gravity = 0.5; // pixels per frame^2 (frame-based feel)

// camera
const camera = { x: 0, y: 0 };

// ---------------------------
// Level control
let level = null;

function loadLevel(index){
  currentLevelIndex = Math.max(0, Math.min(LEVEL_COUNT-1, index));
  level = JSON.parse(JSON.stringify(levels[currentLevelIndex])); // copy so coin state is independent
  // reset coins flag
  level.coins.forEach(c => c.collected = false);
  // reset player
  player.x = 120;
  player.y = H - 220;
  player.vx = 0;
  player.vy = 0;
  player.onGround = false;
  player.coyoteTimer = 0;
  player.jumpBufferTimer = 0;
  coinsCollected = 0;
  updateHUD();
  camera.x = 0;
  camera.y = 0;
}

// update HUD
function updateHUD(){
  levelDisplay.textContent = `Level ${currentLevelIndex + 1} / ${LEVEL_COUNT}`;
  coinCount.textContent = coinsCollected;
}

// Start the game (from menu)
function startGame(){
  loadLevel(currentLevelIndex);
  running = true;
  paused = false;
  menuEl.style.display = 'none';
  requestAnimationFrame(loop);
}

// Restart current level
function restartLevel(){
  loadLevel(currentLevelIndex);
  paused = false;
  running = true;
  menuEl.style.display = 'none';
}

// End game -> back to menu
function goToMenu(){
  running = false;
  paused = false;
  menuEl.style.display = 'flex';
  updateHUD();
}

// ---------------------------
// Collision helpers

function rectIntersects(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

// precise coll with platform (AABB with previous position for ground detection)
function resolvePlayerPlatformCollision(px, py, pw, ph, vx, vy, platform){
  const pBox = { x: px, y: py, w: pw, h: ph };
  const plat = { x: platform.x, y: platform.y, w: platform.w, h: platform.h };
  if (!rectIntersects(pBox, plat)) return null;
  // Determine minimal translation to push out
  const overlapX1 = (pBox.x + pBox.w) - plat.x;
  const overlapX2 = (plat.x + plat.w) - pBox.x;
  const overlapY1 = (pBox.y + pBox.h) - plat.y;
  const overlapY2 = (plat.y + plat.h) - pBox.y;
  const minOverlap = Math.min(overlapX1, overlapX2, overlapY1, overlapY2);
  if (minOverlap === overlapY1) {
    // collided from top
    return { side: 'top', y: plat.y - pBox.h };
  } else if (minOverlap === overlapY2) {
    // collided from bottom
    return { side: 'bottom', y: plat.y + plat.h };
  } else if (minOverlap === overlapX1) {
    // left
    return { side: 'left', x: plat.x - pBox.w };
  } else {
    // right
    return { side: 'right', x: plat.x + plat.w };
  }
}

// ---------------------------
// Game loop

let last = performance.now();
function loop(t){
  if (!running) return;
  const dt = Math.min(32, t - last); // clamp for stability (ms)
  last = t;
  if (!paused) update(dt);
  draw();
  if (running) requestAnimationFrame(loop);
}

// Update logic
function update(dt){
  // input
  const left = keys['arrowleft'] || keys['a'];
  const right = keys['arrowright'] || keys['d'];
  const jumpKey = keys[' '] || keys['spacebar'];

  // Horizontal accel & friction
  const acc = player.speed * dt;
  if (left) { player.vx -= acc; player.facing = -1; }
  if (right) { player.vx += acc; player.facing = 1; }
  // apply friction if no input
  if (!left && !right) {
    player.vx *= 0.86; // ground air friction feel
    if (Math.abs(player.vx) < 0.02) player.vx = 0;
  }
  // clamp
  if (player.vx > player.maxSpeed) player.vx = player.maxSpeed;
  if (player.vx < -player.maxSpeed) player.vx = -player.maxSpeed;

  // gravity
  player.vy += gravity * (dt / 16.67); // scale slightly with dt

  // jump buffering & coyote time
  if (jumpKey) player.jumpBufferTimer = player.jumpBuffer;
  else player.jumpBufferTimer = Math.max(0, player.jumpBufferTimer - dt);

  player.coyoteTimer = Math.max(0, player.coyoteTimer - dt);

  // Attempt jump
  if (player.jumpBufferTimer > 0 && (player.onGround || player.coyoteTimer > 0)) {
    player.vy = -player.jumpStrength;
    player.onGround = false;
    player.coyoteTimer = 0;
    player.jumpBufferTimer = 0;
  }

  // integrate
  const prevX = player.x;
  const prevY = player.y;
  player.x += player.vx;
  player.y += player.vy;

  // simple world bounds X
  if (player.x < -40) player.x = -40;
  if (player.x > level.width + 40 - player.w) player.x = Math.min(level.width - player.w + 40, player.x);

  // collisions with platforms
  player.onGround = false;
  for (const p of level.platforms){
    const res = resolvePlayerPlatformCollision(player.x, player.y, player.w, player.h, player.vx, player.vy, p);
    if (!res) continue;
    if (res.side === 'top'){
      // land on platform
      player.y = res.y;
      player.vy = 0;
      player.onGround = true;
      player.coyoteTimer = player.coyoteTime; // allow small window after leaving
    } else if (res.side === 'bottom'){
      player.y = res.y;
      player.vy = Math.max(0, player.vy);
    } else if (res.side === 'left'){
      player.x = res.x;
      player.vx = Math.min(0, player.vx);
    } else if (res.side === 'right'){
      player.x = res.x;
      player.vx = Math.max(0, player.vx);
    }
  }

  // coins
  for (const c of level.coins){
    if (c.collected) continue;
    const dx = (player.x + player.w/2) - c.x;
    const dy = (player.y + player.h/2) - c.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < c.r + Math.max(player.w, player.h)/3) {
      c.collected = true;
      coinsCollected++;
      updateHUD();
    }
  }

  // star (goal) check — simple AABB check
  const star = level.star;
  const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
  const starRect = { x: star.x - star.r, y: star.y - star.r, w: star.r*2, h: star.r*2 };
  if (rectIntersects(playerRect, starRect)) {
    // advance level
    if (currentLevelIndex < LEVEL_COUNT - 1) {
      currentLevelIndex++;
      loadLevel(currentLevelIndex);
    } else {
      // finished all levels -> show menu with congrats
      running = false;
      menuEl.style.display = 'flex';
      menuEl.querySelector('h1').textContent = 'You beat all 100 levels! 🎉';
      menuEl.querySelector('p').textContent = 'Amazing — refresh or press Start to play again.';
      startBtn.textContent = 'Play Again';
    }
    return;
  }

  // fall death -> back to menu
  if (player.y > H + 150) {
    // go back to menu
    menuEl.style.display = 'flex';
    running = false;
    paused = false;
    menuEl.querySelector('h1').textContent = 'Oh no! You fell 😿';
    menuEl.querySelector('p').textContent = 'Try again — press Start or Space to jump back in.';
    startBtn.textContent = 'Restart';
  }

  // camera follow with smoothing
  const targetCamX = Math.max(0, player.x - W * 0.35);
  camera.x += (targetCamX - camera.x) * 0.12;
  camera.y = 0;

  // update HUD position if needed
  updateHUD();
}

// ---------------------------
// Drawing helpers (cute style)
function drawRoundedRect(x,y,w,h,r=6){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.fill();
}

// draw star
function drawStar(cx,cy,r, spikes=5){
  ctx.save();
  ctx.beginPath();
  const outer = r;
  const inner = r*0.5;
  let rot = Math.PI/2 * 3;
  let x = cx;
  let y = cy;
  const step = Math.PI / spikes;
  ctx.moveTo(cx, cy - outer);
  for(let i=0;i<spikes;i++){
    x = cx + Math.cos(rot) * outer; y = cy + Math.sin(rot) * outer;
    ctx.lineTo(x,y);
    rot += step;
    x = cx + Math.cos(rot) * inner; y = cy + Math.sin(rot) * inner;
    ctx.lineTo(x,y);
    rot += step;
  }
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// draw coin
function drawCoin(x,y,r){
  ctx.beginPath();
  ctx.ellipse(x,y,r*1.1,r,0,0,Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.6)';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.strokeStyle = 'transparent';
}

// Draw frame
function draw(){
  // background pastel sky with subtle hills
  ctx.clearRect(0,0,W,H);
  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#FFF4F9');
  g.addColorStop(0.5,'#FCE9FF');
  g.addColorStop(1,'#E7F7FF');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // cute distant hills
  const hillColors = ['#FDECF7','#E9E9FF','#DDF6F8'];
  for (let i=0;i<3;i++){
    ctx.fillStyle = hillColors[i];
    ctx.beginPath();
    const amp = 80 + i*30;
    ctx.moveTo(-200, H*0.85 - i*40);
    for (let x = -200; x <= W + 400; x += 60){
      const y = H*0.85 - i*40 - Math.sin((x*0.003) + i)*amp;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(W + 400, H + 200);
    ctx.lineTo(-200, H + 200);
    ctx.closePath();
    ctx.fill();
  }

  // ground / level area (draw a soft horizontal band)
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillRect(0, H - 120, W, 120);

  // camera translate
  ctx.save();
  ctx.translate(-Math.round(camera.x), -Math.round(camera.y));

  // draw platforms
  for (const p of level.platforms){
    // platform body
    ctx.fillStyle = `hsl(${40 + (p.x % 200)}, 80%, ${55 - (p.y % 20)}%)`;
    drawRoundedRect(p.x, p.y, p.w, p.h, 9);
    // platform top shine
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    drawRoundedRect(p.x + 6, p.y + 2, Math.max(0, p.w - 12), 6, 6);
  }

  // draw coins
  for (const c of level.coins){
    if (c.collected) continue;
    ctx.fillStyle = '#FFD66B';
    drawCoin(c.x, c.y, c.r);
    // glint
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.ellipse(c.x - c.r*0.2, c.y - c.r*0.25, c.r*0.25, c.r*0.1, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // draw star (goal)
  ctx.save();
  ctx.translate(level.star.x, level.star.y);
  // rotating star animation
  const spin = (performance.now() / 500) % (Math.PI*2);
  ctx.rotate(spin);
  ctx.fillStyle = '#FFF59A';
  drawStar(0,0, level.star.r, 6);
  ctx.fillStyle = '#FFD54A';
  ctx.beginPath();
  ctx.arc(0,0,8,0,Math.PI*2);
  ctx.fill();
  ctx.restore();

  // draw player (cute rounded rectangle with eyes)
  ctx.fillStyle = player.color;
  const px = player.x;
  const py = player.y;
  drawRoundedRect(px, py, player.w, player.h, 10);

  // face / eyes
  ctx.fillStyle = '#2B2B2B';
  const eyeY = py + player.h * 0.36;
  ctx.beginPath();
  ctx.ellipse(px + player.w*0.33, eyeY, 3.8, 5.2, 0, 0, Math.PI*2);
  ctx.ellipse(px + player.w*0.67, eyeY, 3.8, 5.2, 0, 0, Math.PI*2);
  ctx.fill();

  // tiny blush
  ctx.fillStyle = 'rgba(255,105,135,0.12)';
  ctx.beginPath();
  ctx.ellipse(px + player.w*0.2, py + player.h*0.6, 8, 4, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(px + player.w*0.8, py + player.h*0.6, 8, 4, 0, 0, Math.PI*2);
  ctx.fill();

  // camera restore
  ctx.restore();

  // overlay UI elements (small)
  if (paused) {
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.font = '44px "Poppins", Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', W/2, H/2 - 10);
    ctx.font = '16px Arial';
    ctx.fillText('Press P to resume', W/2, H/2 + 26);
  }
}

// init menu texts
menuEl.querySelector('h1').textContent = '✨ Cute Platformer ✨';
menuEl.querySelector('p').textContent = '100 tiny levels — reach the star to advance. Controls: ← → + Space (jump).';

// initial HUD update
updateHUD();

</script>
</body>
</html>
